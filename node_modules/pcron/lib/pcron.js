/*
* Copyright (C) 2012 Singly, Inc. All Rights Reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*    * Redistributions of source code must retain the above copyright
*      notice, this list of conditions and the following disclaimer.
*    * Redistributions in binary form must reproduce the above copyright
*      notice, this list of conditions and the following disclaimer in the
*      documentation and/or other materials provided with the distribution.
*    * Neither the name of the Locker Project nor the
*      names of its contributors may be used to endorse or promote products
*      derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE LOCKER PROJECT BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var async = require("async");
var fs = require("fs");
var path = require("path");
var _ = require("underscore");

exports.init = function (rclient) {
  var scripts = {};

  function loadScript(filename, cbDone) {
    var scriptName = path.join(path.dirname(module.filename), filename);
    var script = fs.readFileSync(scriptName, "utf8");
    rclient.send_command("SCRIPT", ["LOAD", script], function (err, result) {
      if (err) {
        console.log("Failed to load script " + filename + ": " + err);
        return cbDone(err);
      }
      scripts[path.basename(filename, ".lua")] = result;
      cbDone();
    });
  }

  function loadScripts(cbDone) {
    // Load each of the lua scripts into redis and save the hash
    // for later execution via EVALSHA
    var scriptList = ["schedule.lua", "notify.lua", "start_work.lua",
                      "finish_work.lua", "gc_work.lua", "schedule_info.lua",
                      "set_master.lua"];
    async.forEachSeries(scriptList, loadScript, cbDone);
  }

  function runScript(scriptname, args, count, cbDone) {
    var scriptid = scripts[scriptname];
    if (count === 0) {
      return cbDone(new Error("Max attempts reached to run " + scriptname));
    }
    rclient.evalsha([scriptid].concat(args),
                    function (err, result) {
                      // No script was present on server; attempt to load
                      // at next available opportunity
                      if (err &&
                          err.toString().indexOf("NOSCRIPT No matching") > 0) {
                        return process.nextTick(function () {
                          loadScripts(function () {
                            runScript(scriptname, args, count - 1, cbDone);
                          });
                        });
                      } else if (err) {
                        // Some other error -- bail
                        console.log("Error invoking " + scriptname + ": " + err);
                        cbDone(err);
                      }
                      cbDone(null, result);
                    });
  }

  this.schedule = function (service, profile, timestamp, force, cbDone) {
    var forceNum = force === true ? 1 : 0;
    var key = service + "_schedule";
    runScript("schedule", [1, key, profile, timestamp, forceNum], 3, cbDone);
  };

  this.notify = function (services, now, cbDone) {
    var schedules = _.map(services, function (s) { return s + "_schedule"; });
    var args = [schedules.length];
    args.push.apply(args, schedules);
    args.push.apply(args, ["pcron_schedules", now]);
    runScript("notify", args, 3, cbDone);
  };

  this.start_work = function (schedule, now, workerId, workerExpiry, cbDone) {
    runScript("start_work", [3, schedule, "pcron_working", workerId, workerExpiry,
                             now], 3, cbDone);
  };

  this.finish_work = function (service, profile, workerId, now, nextrun, cbDone) {
    var key = service + "_schedule";
    runScript("finish_work", [3, key, "pcron_working", workerId,
                              profile, now, nextrun, "pcron_info"],
              3, cbDone);
  };

  this.gc_work = function (services, now, delay, cbDone) {
    var schedules = _.map(services, function (s) { return s + "_schedule"; });
    schedules.unshift("pcron_working");
    var args = [schedules.length];
    args.push.apply(args, schedules);
    args.push.apply(args, [now, delay, "pcron_info"]);
    runScript("gc_work", args, 3, cbDone);
  };

  this.schedule_info = function (services, now, cbDone) {
    var schedules = _.map(services, function (s) { return s + "_schedule"; });
    var args = [schedules.length];
    args.push.apply(args, schedules);
    args.push(now);
    runScript("schedule_info", args, 3, cbDone);
  };

  this.set_master = function (workerId, expiration, cbDone) {
    runScript("set_master", [1, "pcron_master", workerId, expiration], 3, cbDone);
  };

  var pcronSup = require("./pcron_sup");
  this.start_sup = pcronSup.start;

  return this;
};

