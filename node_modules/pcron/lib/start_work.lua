--
-- Copyright (C) 2012 Singly, Inc. All Rights Reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are met:
--    * Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--    * Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in the
--      documentation and/or other materials provided with the distribution.
--    * Neither the name of the Locker Project nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-- ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-- WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-- DISCLAIMED. IN NO EVENT SHALL THE LOCKER PROJECT BE LIABLE FOR ANY
-- DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-- LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-- ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-- Given a queue and the current time, get the first item that's ready to be
-- processed. Once it's removed from the schedule, it's added to a "working set"
-- and also stored in a expiring hashtable associated with the worker.  The
-- worker must keep renewing the hashtable to indicate that it's making progress
-- on the item or else the GC will eventually push it back into the schedule for
-- processing.
--
-- If there are no items ready to process, return nil.

-- If the item from the schedule is already in working set, we generate an error,
-- since the point of all these Lua scripts is to ensure that items are atomically
-- managed.

local schedule    = KEYS[1]
local working_set = KEYS[2]     -- hashtable (profile, worker_info)
local worker_info = KEYS[3]     -- expiring hashtable of metadata

local expiry = tonumber(ARGV[1])
local now    = tonumber(ARGV[2])   -- current time

-- Get the next available item from the schedule
-- (N.B. that we get a table with key/score back from ZRANGEBYSCORE and
-- tables are ONE-indexed, not ZERO-indexed)
local profile = redis.call('ZRANGEBYSCORE', schedule, -1, now, 'WITHSCORES',
                           'LIMIT', 0, 1)

-- If no items available to process right now, bail
if profile[1] == nil then
   return nil
end

-- Convert the profile into profile@service by removing the _schedule
-- postfix
local service = string.gsub(schedule, "_schedule", "")
local fullid = string.format("%s@%s", profile[1], service)

-- Time at which this item was scheduled to be processed.
local ststamp = profile[2];

-- Insert the item into the working_set (if it's already there, we'll generate
-- an error). We store the worker_info key for GC purposes.
redis.call('HSETNX', working_set, fullid, worker_info)

-- Insert the info into the working_info as well (but as multiple fields,
-- "started", "scheduled" and "profile")
redis.call('HSET', worker_info, "started", now)
redis.call('HSET', worker_info, "scheduled", ststamp)
redis.call('HSET', worker_info, "profile", fullid)

-- Tag the worker_info to expire in X seconds
redis.call('EXPIRE', worker_info, expiry);

-- Finally, remove the item from schedule
redis.call('ZREM', schedule, profile[1])

return fullid;
