--
-- Copyright (C) 2012 Singly, Inc. All Rights Reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are met:
--    * Redistributions of source code must retain the above copyright
--      notice, this list of conditions and the following disclaimer.
--    * Redistributions in binary form must reproduce the above copyright
--      notice, this list of conditions and the following disclaimer in the
--      documentation and/or other materials provided with the distribution.
--    * Neither the name of the Locker Project nor the
--      names of its contributors may be used to endorse or promote products
--      derived from this software without specific prior written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-- ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-- WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-- DISCLAIMED. IN NO EVENT SHALL THE LOCKER PROJECT BE LIABLE FOR ANY
-- DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-- LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-- ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-- Given a working set, scan all the profiles which are associated with expired
-- worker_info. We then re-schedule those items for immediate processing.
--
-- One unfortunate aspect to this routine is that it can only reschedule (and
-- hence GC) idrs for services that are known ahead of time. It has to be this
-- way due to the redis requirement that all keys which require modification
-- must be declared in the KEYS argument.

local working_set = KEYS[1]     -- hashtable (profile, worker_info)

local now = tonumber(ARGV[1])   -- current time
local delay = tonumber(ARGV[2]) -- seconds from now to reschedule things
local info = ARGV[3]            -- info channel

-- Walk all the KEYS and construct a table that will allow us to quickly
-- determine if a given service is present
local services = {}
for i, schedule in ipairs(KEYS) do
   local service = string.gsub(schedule, "_schedule", "")
   services[service] = true
end

local working_set_keys = redis.call('HKEYS', working_set)
for i, idr in ipairs(working_set_keys) do
   local worker = redis.call('HGET', working_set, idr)

   if redis.call('HGET', worker, "profile") ~= idr then
      -- Parse out service/profile from the idr (Lua really needs a better string lib!)
      -- N.B. that parsedId is a _iterator_
      local profile, service = string.gmatch(idr, "(.*)@(.*)")()
      local schedule = service .. "_schedule";

      -- If the service is present in our list of known services,
      -- we can go ahead and reschedule the profile for processing.
      if services[service] then
         -- Schedule the profile for processing after delay seconds
         redis.call('ZADD', schedule, now + delay, profile)

         -- Remove the entry from working_set
         redis.call('HDEL', working_set, idr)

         -- Send a GC notification on the info channel; policy on dealing with too
         -- many reschedules will be handled by listeners there
         local msg = string.format("gc %s %s %s", profile, service, worker)
         redis.call('PUBLISH', info, msg)
      else
         -- Unknown service -- generate a gc warning on the info channel
         local msg = string.format("gc_failed unknown_service %s %s",
                                   profile, service)
         redis.call('PUBLISH', info, msg)
      end
   end
end

