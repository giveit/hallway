/*
* Copyright (C) 2012 Singly, Inc. All Rights Reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*    * Redistributions of source code must retain the above copyright
*      notice, this list of conditions and the following disclaimer.
*    * Redistributions in binary form must reproduce the above copyright
*      notice, this list of conditions and the following disclaimer in the
*      documentation and/or other materials provided with the distribution.
*    * Neither the name of the Locker Project nor the
*      names of its contributors may be used to endorse or promote products
*      derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE LOCKER PROJECT BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var _ = require("underscore");
var assert = require("assert");
var async = require("async");
var pcron = require("pcron");
var pcronSup = require("pcron_sup");

var SERVICE = "supservice";
var SCHED   = "supservice_schedule";
var PROFILES = ["p0", "p1"];
var WORKERID = "supworker";

var redis = require("redis");

var rclient;
var rpubsub;
var pcronInst;

var BASE_CONFIG = {
  services: [SERVICE],
  workerId: WORKERID,
  heartbeatInterval: 900,
  maxRuntimeInterval: 2000,
  watchdogInterval: 500,
  workerRefreshInterval: 1,
  childStopInterval: 1000
};

var triggerEvents = {};         // Map of regex string -> callback which are
                                // invoked when event happens

function waitFor(regexStr, callback, count) {
  if (count === null) count = 1;
  triggerEvents[regexStr] = { cb: callback, count: count };
}

function trigger(channel, msg) {
  var fqmsg = channel + ": " + msg;
//  console.log("M: " + fqmsg);
  _.map(_.pairs(triggerEvents), function(event) {
    var regex = event[0];
    var cbInfo = event[1];
    if (fqmsg.match(new RegExp(regex))) {
      if (--cbInfo.count === 0) {
        console.log("Deleting regex: " + regex);
        delete triggerEvents[regex];
      }
      cbInfo.cb();
    }
  });
}


describe('pcron_sup', function () {
  // Set all tests in this suite to timeout after 10 seconds; this is necessary
  // to ensure that all the sub-timeouts in the sup get a chance to fire
  this.timeout(60000);

  var gcInterval;
  var notifyInterval;
  var sup = null;                 // Currently active version of the sup
  var config;

  beforeEach(function (cbDone) {
    config = _.clone(BASE_CONFIG);
    triggerEvents = {};         //  Reset triggers
    rclient = redis.createClient();
    rpubsub = redis.createClient();
    rclient.flushall(function (err) {
      assert.ifError(err);
      rpubsub.on("message", trigger);
      rpubsub.subscribe(["pcron_info", "pcron_schedules", "pcron_sup"], function () {
        cbDone();
      });
    });

    pcronInst = pcron.init(rclient);

    // Schedule notification scan twice a second
    notifyInterval = setInterval(function () {
      pcronInst.notify([SERVICE], Date.now(), function () {});
    }, 250);

    // Schedule GC twice a second
    gcInterval = setInterval(function () {
      var now = (new Date()).getTime();
      pcronInst.gc_work([SERVICE], now, 1, function () {});
    }, 250);
  });

  afterEach(function (cbDone) {
    assert.notEqual(null, sup);

    // Terminate redis conns
    rclient.end();
    rpubsub.end();

    // Cleanup timers
    clearInterval(gcInterval);
    clearInterval(notifyInterval);

    // Stop the supervisor
    sup.stop(function () {
      sup = null;
      cbDone();
    });
  });

  it('should roundtrip a profile', function (cbDone) {
    // Schedule some work
    pcronInst.schedule(SERVICE, PROFILES[0], 0, false, function (err) {
      assert.ifError(err);

      // Wait for completion event for this profile
      waitFor("runtime .* " + PROFILES[0] + "@" + SERVICE, cbDone);

      // Start the worker
      config.moduleName = "test/lib/suptest_roundtrip.js";
      pcronSup.start(config, function (err, newSup) {
        assert.ifError(err);
        sup = newSup;           // Store sup instance globally for cleanup
      });
    });
  });

  it("should roundtrip 250 profiles with variable failures", function (cbDone) {
    // Process 250 profiles with a jittery worker. Even with all the partial failures,
    // GC should catch items that don't get finished, re-enqueue them and eventually
    // all will be processed.
    this.timeout(0);
    var COUNT = 250;
    var count = COUNT;
    async.whilst(function () { return count >= 0; },
                 function (callback) {
                   pcronInst.schedule(SERVICE, "p" + count, 0, false, function(err) {
                     assert.ifError(err);
                     count--;
                     callback();
                   })
                 },
                 function (err) {
                   assert.ifError(err);

                   // Wait for completion events
                   var counter = COUNT;
                   waitFor("runtime .*@" + SERVICE, function () {
                     if (--counter === 0) cbDone();
                   });

                   config.moduleName = "test/lib/suptest_roundtrip_jitter.js";
                   pcronSup.start(config, function(err, newSup) {
                     assert.ifError(err);
                     sup = newSup;
                   });
                 });
  });

  // Restart tests:
  // 1. Self-terminating child (e.g. child calls process.exit())
  // 2. Non-responsive child (e.g. nodejs never gets back to run-loop)
  // 3. Externally terminated child (e.g. admin invokes kill -9 on the child process)
  //
  // In each of these tests, we should see work being taken but never completed
  // and a GC notification for each item of work fired.
  var restart_tests = [{id: "should restart a non-responsive child",
                        module: "test/lib/suptest_unresponsive.js"},
                       {id: "should restart a self-terminating child",
                        module: "test/lib/suptest_exitonwork.js"},
                       {id: "should restart on external terminate",
                        module: "test/lib/suptest_externalterm.js"}];
  restart_tests.forEach(function (test) {
    it(test.id, function (cbDone) {
      // Schedule all the profiles for t=0
      async.forEachSeries(PROFILES, function (p, nextCb) {
        pcronInst.schedule(SERVICE, p, 0, false, nextCb);
      }, function (err) {
        assert.ifError(err);

        // Wait for two GC events to fire
        var counter = 2;
        waitFor("gc .*" + SERVICE, function () { if (--counter === 0) cbDone(); });

        // Start the worker
        config.moduleName = test.module,
        pcronSup.start(config, function (err, newSup) {
          assert.ifError(err);
          sup = newSup;           // Store sup instance globally for cleanup
        });
      });
    });
  });

});
