/*
* Copyright (C) 2012 Singly, Inc. All Rights Reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*    * Redistributions of source code must retain the above copyright
*      notice, this list of conditions and the following disclaimer.
*    * Redistributions in binary form must reproduce the above copyright
*      notice, this list of conditions and the following disclaimer in the
*      documentation and/or other materials provided with the distribution.
*    * Neither the name of the Locker Project nor the
*      names of its contributors may be used to endorse or promote products
*      derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE LOCKER PROJECT BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var assert = require("assert");
var async = require("async");
var pcron = require("pcron");

var redis = require("redis");

var rclient;
var rpubsub;
var pcronInst;

var SERVICE     = "testservice";
var PROFILES    = ["p0", "p1", "p2", "p3", "p4"];
var PROFILE     = PROFILES[0];
var SCHED       = SERVICE + "_schedule";
var WORKER_INFO = "testworker_info";
var WORKING_SET = "pcron_working";
var CHANNEL     = "pcron_schedules";

// Helper function that invokes a Redis command and validates
// result matches what we expect
function rAssert(cmd, args, expected) {
  return function (cbDone) {
    rclient.send_command(cmd, args, function (err, result) {
      assert.ifError(err);
      assert.deepEqual(expected, result);
      cbDone();
    });
  };
}


describe('pcron', function () {

  beforeEach(function (cbDone) {
    rclient = redis.createClient();
    rpubsub = redis.createClient();
    rclient.del([SCHED, WORKING_SET, WORKER_INFO], cbDone);
    pcronInst = pcron.init(rclient);
  });

  afterEach(function (cbDone) {
    rclient.end();
    rpubsub.end();
    cbDone();
  });

  it('should insert when service does not exist yet', function (cbDone) {
    pcronInst.schedule(SERVICE, PROFILE, 123, false, function (err, result) {
      assert.ifError(err);
      assert.equal(123, result);  // Timestamp of inserted value
      async.series([
        rAssert("ZSCORE", [SCHED, PROFILE], 123)
      ], cbDone);
    });
  });

  it('should not insert when profile has lower tstamp', function (cbDone) {
    // Insert profile with low tstamp of 1
    rclient.zadd([SCHED, 1, PROFILE], function (err, result) {
      assert.ifError(err);
      assert.equal(1, result);  // Timestamp of inserted value

      // Now attempt to schedule the same profile at tstamp == 123; this
      // should fail as we are already scheduled to process it sooner
      pcronInst.schedule(SERVICE, PROFILE, 123, false, function (err, result) {
        assert.ifError(err);
        assert.equal(1, result);  // Returns the lowest tstamp (1 in this case)

        async.series([
          rAssert("ZSCORE", [SCHED, PROFILE], 1)
        ], cbDone);
      });
    });
  });

  it('should insert when profile has lower tstamp and forced', function (cbDone) {
    // Insert profile with low tstamp of 1
    rclient.zadd([SCHED, 1, PROFILE], function (err, result) {
      assert.ifError(err);
      assert.equal(1, result);  // Timestamp of inserted value

      // Now attempt to schedule the same profile at tstamp == 123 AND
      // FORCE IT. This should have the effect of setting the tstamp to the
      // value of 123
      pcronInst.schedule(SERVICE, PROFILE, 123, true, function (err, result) {
        assert.ifError(err);
        assert.equal(123, result);  // Returns the forced tstamp
        async.series([
          rAssert("ZSCORE", [SCHED, PROFILE], 123)
        ], cbDone);
      });
    });
  });

  it('should reload script automagically', function (cbDone) {
    rclient.send_command("SCRIPT", ["FLUSH"], function (err) {
      assert.ifError(err);
      pcronInst.schedule(SERVICE, PROFILE, 123, false, function (err, result) {
        assert.ifError(err);
        assert.equal(123, result);  // Timestamp of inserted value
        async.series([
          rAssert("ZSCORE", [SCHED, PROFILE], 123)
        ], cbDone);
      });
    });
  });


  it('should notify with zero when no work is ready', function (cbDone) {
    rpubsub.on("message", function (channel, message) {
      // Validate that the message has zero items ready for the schedule; then finish up
      // the test
      assert.deepEqual("pending 0 " + SCHED, message);
      cbDone();
    });
    rpubsub.on("subscribe", function () {
      // Bulk of test runs here -- we want to ensure the subscription is ready before we
      // continue

      // Schedule work for t=123
      var t = 123;
      async.forEachSeries(PROFILES, function (p, cbDone) {
        pcronInst.schedule(SERVICE, p, t, false, cbDone);
      }, function (err) {
        assert.ifError(err);
        // Generate notification at t=0
        pcronInst.notify([SERVICE], 0, function () {});
      });
    });
    rpubsub.subscribe(CHANNEL);
  });

  it('should notify with correct count work is ready', function (cbDone) {
    rpubsub.on("message", function (channel, message) {
      // Validate that the message has 3 items ready for the schedule; then finish up
      // the test
      assert.deepEqual("pending 3 " + SCHED, message);
      cbDone();
    });
    rpubsub.on("subscribe", function () {
      // Bulk of test runs here -- we want to ensure the subscription is ready before we
      // continue

      // Schedule work for t=98..102
      var t = 98;
      async.forEachSeries(PROFILES, function (p, cbDone) {
        pcronInst.schedule(SERVICE, p, t++, false, cbDone);
      }, function (err) {
        assert.ifError(err);
        // Generate notification at t=100
        pcronInst.notify([SERVICE], 100, function () {});
      });
    });
    rpubsub.subscribe(CHANNEL);
  });

  it('should noop when nothing is scheduled to run', function (cbDone) {
    // Schedule all the profiles for t=100
    async.forEachSeries(PROFILES, function (p, cbDone) {
      pcronInst.schedule(SERVICE, p, 100, false, cbDone);
    }, function (err) {
      assert.ifError(err);
      // Attempt to start work on the next item, t=0
      pcronInst.start_work(SCHED, 0, WORKER_INFO, 60, function (err, result) {
        assert.ifError(err);
        assert.equal(null, result);
        cbDone();
      });
    });
  });

  it('should move item from schedule to working_set/worker', function (cbDone) {
    // Schedule all the profiles for t=0
    async.forEachSeries(PROFILES, function (p, cbDone) {
      pcronInst.schedule(SERVICE, p, 0, false, cbDone);
    }, function (err) {
      assert.ifError(err);
      // Attempt to dequeue the next item, now=t=5
      pcronInst.start_work(SCHED, 5, WORKER_INFO, 60, function (err, result) {
        assert.ifError(err);
        assert.deepEqual("p0@testservice", result);
        // Validate a number of postconditions
        // 1. Profile ID is in WORKING_SET
        // 2. Profile ID is NOT in schedule
        // 3. Profile ID is in WORKER_KEY.profile
        // 4. Started time = 5 (now)
        // 5. Scheduled time = 0
        async.series([
          rAssert("HEXISTS", [WORKING_SET, "p0@testservice"], true),
          rAssert("ZRANK", [SCHED, "p0"], null),
          rAssert("HGET", [WORKER_INFO, "profile"], "p0@testservice"),
          rAssert("HGET", [WORKER_INFO, "started"], 5),
          rAssert("HGET", [WORKER_INFO, "scheduled"], 0)
        ], cbDone);
      });
    });
  });

  it('should not cleanup profiles owned by a different worker', function (cbDone) {
    // Schedule work at t=0
    pcronInst.schedule(SERVICE, PROFILE, 0, false, function (err, result) {
      assert.ifError(err);
      assert.equal(0, result);
      // Have worker A start working on the profile
      pcronInst.start_work(SCHED, 0, "workerA", 60, function (err, result) {
        assert.ifError(err);
        assert.deepEqual("p0@testservice", result);
        // Now attempt to have worker B finish the work
        pcronInst.finish_work(SERVICE, PROFILE, "workerB", 2, 5, function (err, result) {
          assert.ifError(err);
          assert.equal(null, result);
          async.series([
            rAssert("HGET", [WORKING_SET, "p0@testservice"], "workerA")
          ], cbDone);
        });
      });
    });
  });

  it('should cleanup working_set', function (cbDone) {
    // Schedule work at t=0
    pcronInst.schedule(SERVICE, PROFILE, 0, false, function (err, result) {
      assert.ifError(err);
      assert.equal(0, result);
      // Start working on the profile
      pcronInst.start_work(SCHED, 0, WORKER_INFO, 60, function (err, result) {
        assert.ifError(err);
        assert.deepEqual("p0@testservice", result);
        // Now finish the work
        pcronInst.finish_work(SERVICE, PROFILE, WORKER_INFO, 2, 5, function (err, result) {
          assert.ifError(err);
          assert.equal(5, result);
          async.series([
            rAssert("ZRANK", [SCHED, "p0"], 0),
            rAssert("HEXISTS", [WORKING_SET, "p0@testservice"], false),
            rAssert("HEXISTS", [WORKER_INFO, "profile"], false),
            rAssert("HEXISTS", [WORKER_INFO, "started"], false),
            rAssert("HEXISTS", [WORKER_INFO, "scheduled"], false)
          ], cbDone);
        });
      });
    });
  });

  it('should not reschedule items with null nextRun time', function (cbDone) {
    // Schedule work at t=0
    pcronInst.schedule(SERVICE, PROFILE, 0, false, function (err, result) {
      assert.ifError(err);
      assert.equal(0, result);
      // Start working on the profile
      pcronInst.start_work(SCHED, 0, WORKER_INFO, 60, function (err, result) {
        assert.ifError(err);
        assert.deepEqual("p0@testservice", result);
        // Now finish the work with null nextRun
        pcronInst.finish_work(SERVICE, PROFILE, WORKER_INFO, 2, null, function (err, result) {
          assert.ifError(err);
          assert.equal(null, result);
          async.series([
            rAssert("ZRANK", [SCHED, "p0"], null),
            rAssert("HEXISTS", [WORKING_SET, "p0@testservice"], false),
            rAssert("HEXISTS", [WORKER_INFO, "profile"], false),
            rAssert("HEXISTS", [WORKER_INFO, "started"], false),
            rAssert("HEXISTS", [WORKER_INFO, "scheduled"], false)
          ], cbDone);
        });
      });
    });
  });

  it.skip('should notify on un-GCable keys', function(cbDone) {
  });

  it.skip('should remove keys with no affiliated worker', function(cbDone) {
  });

  it('should always win master lock when expiration is long enough', function (cbDone) {
    // Grab the lock for w1 before scheduling w2 for first time. Thereafter, let them
    // run independently
    var w1, w2;
    pcronInst.set_master("w1", 10000, function (err, result) {
      if (err) return cbDone(err);
      assert.equal(1, result);
      // Now schedule calls to both w1 and w2 at random times less than expiration
      w1 = setInterval(function () {
        pcronInst.set_master("w1", 10000, function (err, result) { assert.equal(1, result); });
      }, 5 + Math.random() * 100);
      w2 = setInterval(function () {
        pcronInst.set_master("w2", 10000, function (err, result) { assert.equal(0, result); });
      }, 5 + Math.random() * 100);

      // Finally, schedule cancellation and completion of test case after 1.5 seconds
      setTimeout(function () {
        clearInterval(w1);
        clearInterval(w2);
        cbDone();
      }, 1500);
    });
  });
});

